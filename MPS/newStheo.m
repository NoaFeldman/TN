function s = newStheo(X0Scaled, XChargeScaled, NA, pointFunc, weight, k)
    % Charge resolved VN entropy based on 
    % s_n(\alpha) = 
    %       s_n(\alpha = 0)[XCharge^{-k/n (\aplha/2pi)^2 +
    %       weight*XCharge^{-k/n ((\alpha \pm 2pi)/2pi)^2]
    % The derivative of the N_A dependence of the Renyi entropies (the part
    % in the square brackets) is taken from Mathematica (vertexOpsWeights.nb 
    % on my gp).
    % The (alpha = 0) entropy dependence on n is assumed to be
    % A = X0_scaled^(-pointFunc*c/12(n - n^-1)), X0_scaled is extracted from
    % sFull.
    if (nargin == 5)
        k = 1;
    end
    
    s = (-1/3).*exp(1).^((sqrt(-1)*(-1)).*NA.*pi).*k.^(-3/2).*pointFunc.^(-3/2).* ...
  pi.*XChargeScaled.^((-9/4).*k.*pointFunc).*log(XChargeScaled).^(-3/2).*(sqrt(-1).*((-1)+exp(1).^( ...
  (sqrt(-1)*2).*NA.*pi).*weight).*XChargeScaled.^(2.*k.*pointFunc).*dawson((1/2).*k.^(-1/2) ...
  .*pointFunc.^(-1/2).*log(XChargeScaled).^(-1/2).*(2.*NA.*pi+(sqrt(-1)*(-1)).*k.*pointFunc.* ...
  log(XChargeScaled))).*(6.*NA.^2.*pi.^2+k.*pointFunc.*log(XChargeScaled).*((-3)+pointFunc.*log(X0Scaled)))+weight.*( ...
  (sqrt(-1)*(-1)).*dawson((1/2).*k.^(-1/2).*pointFunc.^(-1/2).*log(XChargeScaled).^( ...
  -1/2).*(2.*NA.*pi+(sqrt(-1)*(-3)).*k.*pointFunc.*log(XChargeScaled))).*(6.*NA.^2.* ...
  pi.^2+k.*pointFunc.*log(XChargeScaled).*((-3)+pointFunc.*log(X0Scaled)))+sqrt(-1).*exp(1).^((sqrt( ...
  -1)*2).*NA.*pi).*dawson((1/2).*k.^(-1/2).*pointFunc.^(-1/2).*log(XChargeScaled).^( ...
  -1/2).*(2.*NA.*pi+(sqrt(-1)*3).*k.*pointFunc.*log(XChargeScaled))).*(6.*NA.^2.*pi.^2+ ...
  k.*pointFunc.*log(XChargeScaled).*((-3)+pointFunc.*log(X0Scaled)))+(-3).*exp(1).^(sqrt(-1).*NA.* ...
  pi).*k.^(1/2).*pointFunc.^(1/2).*log(XChargeScaled).^(1/2).*(3.*k.*pointFunc.*cos(NA.*pi).* ...
  log(XChargeScaled)+(-2).*NA.*pi.*sin(NA.*pi)))+XChargeScaled.^(2.*k.*pointFunc).*(sqrt(-1).*(exp( ...
  1).^((sqrt(-1)*2).*NA.*pi)+(-1).*weight).*dawson((1/2).*k.^(-1/2).* ...
  pointFunc.^(-1/2).*log(XChargeScaled).^(-1/2).*(2.*NA.*pi+sqrt(-1).*k.*pointFunc.*log(XChargeScaled))).* ...
  (6.*NA.^2.*pi.^2+k.*pointFunc.*log(XChargeScaled).*((-3)+pointFunc.*log(X0Scaled)))+3.*exp(1).^( ...
  sqrt(-1).*NA.*pi).*k.^(1/2).*pointFunc.^(1/2).*log(XChargeScaled).^(1/2).*(k.*pointFunc.*(( ...
  -1)+weight).*cos(NA.*pi).*log(XChargeScaled)+2.*NA.*pi.*(1+weight).*sin(NA.*pi))));
    
end
    
function a = A(X)
    a = 1;
end

function da = dnA(X, pointFunc)
    c = 1;
    da = -(pointFunc*c/6).* log(X);
end

function res = chargeDependentRenyi(pointFunc, NA, k, X, w)
    xP = k * pointFunc .* log(X);
    naP = 2 .*NA * pi;
    res = -1./sqrt(xP).* 1i .* exp(-NA.^2*pi^2./xP) .* pi^(3/2) .* ...
        ((-1 + 2.*exp(1i .* naP)*w).*erfi((naP - 1i.*xP)./(2.*sqrt(xP))) + ...
        erfi((naP + 1i.*xP)./(2.*sqrt(xP))) - ...
        2.*exp(1i .* naP)*w.*erfi((naP - 3i.*xP)./(2.*sqrt(xP))));
end

function res = chargeDependentRenyiDerivative(pointFunc, NA, k, X, w)
    xP = k * pointFunc .* log(X);
    naP = 2 .*NA * pi;
    res = 1./(2.*(xP).^(3/2)) .* exp(-1i .* NA * pi) * pi .* X.^(-9 * k * pointFunc / 4) .* ...
        (2 .* sqrt(xP) * w .* (1i .* naP - 3.*xP) + ...
             2i .* (X.^(2*k*pointFunc).*((-1 + 2.*exp(1i .* naP).*w).*dawson((naP - 1i.*xP)./(2.*sqrt(xP))) + ...
                                        exp(1i .*  naP).*dawson((naP + 1i.*xP)./(2.*sqrt(xP)))) - ...
                   2*w.*dawson((naP - 3i.*xP)./(2.*sqrt(xP)))).* ...
             (2.*NA.^2*pi^2 - xP) + ...
         sqrt(xP).*X.^(2*k*pointFunc).*(1i .* naP .*(1 - exp(1i.*naP).*(1+2*w)) + ...
                                        xP.*(-1 + exp(1i .* naP).*(-1 + 2*w))));
        
end

function res = erfi(z)
    res = erfz(1i .* z) ./ 1i;
end