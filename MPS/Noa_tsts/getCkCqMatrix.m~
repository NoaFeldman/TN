function A = getCkCqMatrix(psi)
    % Creates A_ij = <psi|Ck^dagger Cq|psi>
    M = getCiCjMatrix(psi);
    S = getTransferMatrix(length(psi));
    A = S' * M * S;
 end    

function M = getCiCjMatrix(psi)
    % Creates M_ij = <psi|Ci^dagger Cj|psi>
    M = zeros(length(psi), length(psi));
    % TODO only apply on site and pass psi to getCiCj.
    CStates = QSpace(length(psi), length(psi));
    for i = 1 : length(CStates)
        CStates(i, :) = applyCn(psi, i);
    end
    for i = 1 : length(M)
        for j = i : length(M)
            M(i, j) = getCiCj(i, j , CStates(i, :), CStates(j, :));
            M(j, i) = conj(M(i, j));
        end
    end
end

function cicj = getCiCj(i, j , CiStates, CjStates) 
    res = QSpace;
    if (i < j)
        res = contract(CjStates(i), '12', CiStates(i), '12*');
        for n = i+1 : j-1
            res = contract(contract(res, 1, CjStates(n), 1), '13', ...
                CiStates(n), '12*', [2 3 1]);
        end
        res = contract(contract(res, '13', CjStates(j), '14'), '12', ...
            CiStates(j), '12*');
    else % i <= j according to getCiCjMatrix
    end
    for n = j+1 : length(CiStates) - 1
        res = contract(res, 1, CjStates(n), 1), '12', CiStates(n)
end

function S = getTransferMatrix(N)
    % Creates the tranfer matrix from real space to dual space.
    % Ci = SikCk
    % We assume open boundary conditions.
    S = zeros(N, N);
    for i = 1 : N
        for k = 1 : i
            S(i, k) = cos(i * getMomentum(k)) / sqrt(N);
            S(k, i) = cos(i * getMomentum(k)) / sqrt(N);
        end
    end
end
            

function E = getEk(N, k)
    % Returns Ek for the k'th allowed value in the dual space (k is an
    % integer).
    % We here use open boundary conditions.
    E = 2 * cos(getMomentum(k));
end

function m = getMomentum(k)
    % Assume open boundary conditions
    m = 2 * pi * k / (N+1);
end