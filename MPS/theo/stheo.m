function s = stheo(X0Scaled, XChargeScaled, NA, pointFunc, weight, k)
    % Charge resolved VN entropy based on 
    % s_n(\alpha) = 
    %       s_n(\alpha = 0)[XCharge^{-k/n (\aplha/2pi)^2 +
    %       weight*XCharge^{-k/n ((\alpha \pm 2pi)/2pi)^2]
    % The (alpha = 0) entropy dependence on n is assumed to be
    % A = X0_scaled^(-pointFunc*c/12(n - n^-1)), X0_scaled is extracted from
    % sFull.
    % Code here is taken from Mathematica (vertexOpsWeights.nb on my gp).
    if (nargin == 5)
        k = 1;
    end
    
    s = (-1/(3*2*pi)).*exp(1).^((sqrt(-1)*(-1)).*NA.*pi).*k.^(-3/2).*pointFunc.^(-3/2).* ...
  pi.*XChargeScaled.^((-9/4).*k.*pointFunc).*log(XChargeScaled).^(-3/2).*(sqrt(-1).*((-1)+exp(1).^( ...
  (sqrt(-1)*2).*NA.*pi).*weight).*XChargeScaled.^(2.*k.*pointFunc).*dawson((1/2).*k.^(-1/2) ...
  .*pointFunc.^(-1/2).*log(XChargeScaled).^(-1/2).*(2.*NA.*pi+(sqrt(-1)*(-1)).*k.*pointFunc.* ...
  log(XChargeScaled))).*(6.*NA.^2.*pi.^2+k.*pointFunc.*log(XChargeScaled).*((-3)+pointFunc.*log(X0Scaled)))+weight.*( ...
  (sqrt(-1)*(-1)).*dawson((1/2).*k.^(-1/2).*pointFunc.^(-1/2).*log(XChargeScaled).^( ...
  -1/2).*(2.*NA.*pi+(sqrt(-1)*(-3)).*k.*pointFunc.*log(XChargeScaled))).*(6.*NA.^2.* ...
  pi.^2+k.*pointFunc.*log(XChargeScaled).*((-3)+pointFunc.*log(X0Scaled)))+sqrt(-1).*exp(1).^((sqrt( ...
  -1)*2).*NA.*pi).*dawson((1/2).*k.^(-1/2).*pointFunc.^(-1/2).*log(XChargeScaled).^( ...
  -1/2).*(2.*NA.*pi+(sqrt(-1)*3).*k.*pointFunc.*log(XChargeScaled))).*(6.*NA.^2.*pi.^2+ ...
  k.*pointFunc.*log(XChargeScaled).*((-3)+pointFunc.*log(X0Scaled)))+(-3).*exp(1).^(sqrt(-1).*NA.* ...
  pi).*k.^(1/2).*pointFunc.^(1/2).*log(XChargeScaled).^(1/2).*(3.*k.*pointFunc.*cos(NA.*pi).* ...
  log(XChargeScaled)+(-2).*NA.*pi.*sin(NA.*pi)))+XChargeScaled.^(2.*k.*pointFunc).*(sqrt(-1).*(exp( ...
  1).^((sqrt(-1)*2).*NA.*pi)+(-1).*weight).*dawson((1/2).*k.^(-1/2).* ...
  pointFunc.^(-1/2).*log(XChargeScaled).^(-1/2).*(2.*NA.*pi+sqrt(-1).*k.*pointFunc.*log(XChargeScaled))).* ...
  (6.*NA.^2.*pi.^2+k.*pointFunc.*log(XChargeScaled).*((-3)+pointFunc.*log(X0Scaled)))+3.*exp(1).^( ...
  sqrt(-1).*NA.*pi).*k.^(1/2).*pointFunc.^(1/2).*log(XChargeScaled).^(1/2).*(k.*pointFunc.*(( ...
  -1)+weight).*cos(NA.*pi).*log(XChargeScaled)+2.*NA.*pi.*(1+weight).*sin(NA.*pi))));    
end
